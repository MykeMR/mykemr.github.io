---
title: JenkHack - DockerLabs
published: true
categories: DockerLabs
---

| OS     | Dificultad  | Creator           |
| ------ | ----------- | ----------------- |
| Linux  |  Fácil      | d1se0        |

# Reconocimiento

Comenzamos el proceso de reconocimiento identificando los puertos abiertos en el sistema objetivo.

```shell
sudo nmap -p- --open -sS --min-rate 5000 -vvv -n -Pn 172.17.0.2 -oG ports
```
- `-p-`: Escanea todos los puertos (1-65535).
- `--open`: Solo muestra los puertos abiertos.
- `-sS`: Realiza un escaneo SYN, que es rápido y discreto.
- `--min-rate=5000`: Envía al menos 5000 paquetes por segundo, acelerando el escaneo.
- `-n`: No realiza resolución DNS.
- `-Pn`: No realiza ping previo para determinar si el host está activo.
- `-vvv`: Muestra resultados detallados y en tiempo real.

![image](https://github.com/user-attachments/assets/21639354-5bbb-44b3-b41c-fd3ffaadc979)

### Puertos Descubiertos

Durante el escaneo, descubrimos los siguientes puertos abiertos:
- `80` (HTTP)
- `443` (HTTPS)
- `8080` (Http-Proxy)

Realizamos un escaneo más detallado para obtener información sobre los servicios en estos puertos:

```bash
nmap -p443,80,8080 -sCV 172.17.0.2 -oG targeted
```

![image](https://github.com/user-attachments/assets/b1e44dfc-dde2-400d-bbe4-3ef4d940bf05)

# Exploración Web

Vemos que tenemos dos paginas la primera en el puerto 80 que es una pagina de informacion como un blog:

![image](https://github.com/user-attachments/assets/9d9cdd02-5038-4d18-837f-52e4b965a1e2)

A simple vista no se ve nada, solo vemos que nos habla cobre el servicio de jenkins que antes hemos visto en el puerto 8080.

Para investigar, utilizamos `Gobuster` y exploramos directorios en el sitio:

```bash
gobuster dir -u http://172.17.0.2 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -x php,doc,html,txt,img
```
- `gobuster dir`: Realiza un escaneo de directorios.
- `-u http://172.17.0.2/`: URL objetivo.
- `-w`: Diccionario a utilizar.
- `-x`: Extensiones de archivo para buscar.

![image](https://github.com/user-attachments/assets/50211da7-4147-47f0-9499-a95c4271cf3e)

No encontramos nada interesante, por lo que probaremos en el 8080, el cual es un panel de login de jenkis.

![image](https://github.com/user-attachments/assets/da625272-5db9-4715-9e3c-99f36ea568c2)

Investigando vemos como hay dos palabras ocultas en el puerto 80 en al codigo fuente:
jenkins-admin y cassandra, por lo que lo porbamos.

![image](https://github.com/user-attachments/assets/cc39aff8-f04f-40df-8377-02b9cabf6ead)

Estamos dentro:

![image](https://github.com/user-attachments/assets/cba550de-aae7-4208-b9b2-7a6cab670c41)

Ahora haremos un RCE a traves de groovy [HackTricks](https://cloud.hacktricks.xyz/es-cloud/pentesting-ci-cd/jenkins-security/jenkins-rce-with-groovy-script).

```bash
https://cloud.hacktricks.xyz/es-cloud/pentesting-ci-cd/jenkins-security/jenkins-rce-with-groovy-script
```
Simultaneamente escuhamos en el puerto 4444 por netcat, y ya estariamos dentro.

![image](https://github.com/user-attachments/assets/ddd22f41-fa09-46b7-8ea5-632a30c452ab)

## TTY ReverseShell

### Iniciar una sesión de shell interactiva
En nuestra shell básica, ejecutamos el siguiente comando para forzar la creación de una sesión de bash interactiva:
```bash
script /dev/null -c bash
```
### Suspender la shell
Una vez que el comando anterior está en ejecución, utilizamos
```bash
Control+Z
```
para suspender temporalmente nuestra shell.

### Preparar nuestro terminal local:
Antes de volver a nuestra shell, configuramos nuestro terminal local:
```bash
stty raw -echo; fg
```

### Resetear la configuración del terminal
Ahora que tenemos el control de la shell, la reseteamos para asegurar que se comporta correctamente:
```bash
reset
```

### Configura el tipo de terminal:
```bash
xterm
export TERM=xterm
export SHELL=bash
```
ya dentro vemos a traves del recurso llamado linpeas.sh, que hay "Explica que es esto (searching root files in home dirs)". El cual tiene lo siguiente:

![image](https://github.com/user-attachments/assets/617e5fb1-1b67-4c8a-a44b-75c65b6935d4)

Vemos que el usuario jenkhack contiene un note.txt vamos a ver que contiene.

```bash
jenkhack:C1V9uBl8!'Ci*`uDfP
```

Parece una contraseña para el usuario jenhack , como no sabemos si esta cifrado , vamos a usar [CyberChef]() ya que es una pagina muy util.

![image](https://github.com/user-attachments/assets/26b27942-33fc-4849-8b6d-3d9839703df1)

Vemos que esta en base85 y la contraseña es `jenkinselmejor`.

Accediendo a ese usuario vemos que ya tenemos acceso.

```bash
su jenhack
```

![image](https://github.com/user-attachments/assets/f72b6901-2b56-42d2-a811-8b6bd8f743f8)


Al ejecutar `sudo -l`, notamos que tiene permisos para ejecutar `bash` como `root`.Utilizando [GTFOBins](https://gtfobins.github.io/gtfobins/awk/#shell) sabemos cómo explotar estos binarios.

```bash
sudo /usr/local/bin/bash -p
```

Siempre que ejecutamos el script salta lo siguiente:

```bash
Welcome to the bash application!
Running command...
This is the bash script running.
```

Por lo que comporbando el archivo vemos que llama a una ruta el opt:

![image](https://github.com/user-attachments/assets/5a8d5768-4e4c-46cb-a6e9-be5943a4c396)

Asi que borramos ese archivo y generamos el nuestro con el cual cambairmos los permiso de bash con chmod u+s /bin/bash. (Explica esto).

![image](https://github.com/user-attachments/assets/38221ef3-2755-497d-abb4-19f6c237671e)

le damos permisos al script.
```bash
chmod +x bash.sh 
```

Si sale el mensaje de funciona es que nos pilla bien el script.

![image](https://github.com/user-attachments/assets/5c4f1309-102c-4473-8620-4043d22f4b35)


Solo queda ejecutar lo siguiente:

```bash
sudo /bin/bash -p
```

Ya somos root.

![image](https://github.com/user-attachments/assets/9992159c-9533-4cc0-84cf-18b0b1477be3)
